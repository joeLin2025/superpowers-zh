---
name: subagent-driven-development
description: 当在当前会话中执行涉及复杂逻辑、多步骤实施或需要严格隔离审查的计划任务时使用。
---

# 子智能体驱动开发 (Subagent-Driven Development)

## 概述

此技能是将主智能体转化为“工程指挥官”的指挥系统。它通过**职责解耦 (Responsibility Decoupling)** 和 **分段审查 (Tiered Review)**，将复杂任务分派给具备特定角色约束的子智能体，从而克服大模型在长上下文下的注意力衰减，实现高精度的代码交付。

**核心原则：**
1.  **角色纯粹性 (Role Purity)**：实施者（Implementer）只管实现，审查者（Reviewer）只管挑错。严禁单一智能体既当运动员又当裁判。
2.  **零信任审计 (Zero-Trust Audit)**：主智能体与审查者必须假设实施者的报告是“美化过的”，必须通过直接审计源代码来验证事实。
3.  **封闭上下文 (Closed Context)**：给子智能体的指令必须是自包含的。严禁让子智能体“猜测”需求或“回忆”之前的对话。

## 何时使用

- 正在执行 `writing-plans` 生成的多步骤计划，且每一步涉及具体的编码工作时。
- 需要并行执行多个原子任务（配合 `dispatching-parallel-agents`）时。
- 任务逻辑极度复杂，主智能体需要保留注意力以维持全局架构视图时。

## 核心法则

### 1. 必须使用“三位一体”委派模板
调用 `delegate_to_agent` 时，**必须**基于以下标准模板注入指令：
- **实施者 (Implementer)**：负责最小化代码实现与 TDD 验证。
- **规格审查者 (Spec Reviewer)**：负责逐行核对代码与需求（Requirements）的匹配度。
- **质量审查者 (Quality Reviewer)**：负责代码风格、健壮性与可维护性审计。

### 2. 必须执行“物理级”任务封装
在分派任务前，主智能体**必须**：
- **动作**：从计划文件中完整复制任务描述，而非提供总结。
- **动作**：明确指定子智能体可读写的文件白名单。
- **约束**：**严禁**子智能体修改其任务范围之外的代码。若发现潜在重构需求，必须返回主智能体处理。

### 3. 必须实施“双重审查”熔断机制
子智能体提交报告后，合并前**必须**：
1.  **第一关：规格审查**：验证是否“不多不少”地完成了任务。若未通过，直接打回。
2.  **第二关：质量审查**：验证是否“又快又稳”地完成了任务。
- **铁律**：主智能体严禁在未经过这两关审查的情况下直接采纳代码改动。

### 4. 必须强制要求“证据链”报告
子智能体的报告**必须**包含：
- **实施路径**：修改了哪些文件的哪几行？
- **验证输出**：具体的测试成功日志或运行截图说明。
- **缺陷自认**：实施过程中跳过了哪些边缘情况（若有）？

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个任务太小了，我自己写快得多” | 你的上下文空间是宝贵的战略资源。子智能体负责战术执行，是为了让你能保持战略清醒。 |
| “审查者太挑剔了，稍微过一下就行” | 挑剔是审查者的职业道德。放过一个小问题，就会在生产环境引发大灾难。 |
| “子智能体应该知道项目规范，不用再写了” | 子智能体是“无状态”的。每一次委派都是一次全新的认知对齐，必须事无巨细。 |

## 危险信号 (Red Flags)

- **单句指令**：给子智能体的指令不足 3 行。
- **盲目信任**：在没有查看子智能体修改的实际代码的情况下就说“看起来不错”。
- **职责混淆**：实施者顺手改了其他模块的代码。
- **审查跳步**：因为赶时间，跳过了规格审查直接合并。
