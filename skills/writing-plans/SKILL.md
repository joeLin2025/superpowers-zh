---
name: writing-plans
description: 当你有了针对多步骤任务的规范或需求，在动手写代码之前使用。
---

# 编写实施计划 (Writing Implementation Plans)

## 概述

此技能强制将高层设计转化为细粒度、可验证的实施步骤。

**核心原则：**
1.  **原子化**：每个步骤必须足够小，仅做一件事，且可独立验证。
2.  **验证驱动**：每个步骤都必须包含明确的验证方法（主要是测试）。
3.  **活文档**：计划不是僵死的文本，而是随着实施进度更新的状态追踪器。

## 何时使用

- **前置条件**：已通过 `brainstorming` 技能产出了设计文档 (Spec) 且获得了用户批准。
- 任务涉及修改多个文件或模块时。
- 任务预计耗时超过 10 分钟或 3 个交互轮次时。

**何时不使用：**
- 缺乏明确的设计文档 (Spec) 时。
- 单行代码修复或纯文档更新。

## 核心法则

### 0. 必须执行“零号检查” (The Pre-flight Check)

在创建任何计划文件**之前**，你**必须**基于已批准的 **设计文档 (Spec)** 明确询问用户并获得以下两个关键决策的答案：

1.  **工作区模式 (Workspace Mode)**：
    *   "是在当前目录直接开发，还是为您创建独立的 Git Worktree？"
    *   *(如果是复杂重构或新功能，强烈推荐 Worktree)*
2.  **交付模式 (Delivery Mode)**：
    *   "每完成一个步骤后，是由我自动在**本地提交** Git (Local Auto-commit)，还是由您自行审查后手动提交到本地？"
    *   *(注：任何模式下，推送到远程仓库 `git push` 的操作均由用户在任务结束后手动执行，智能体严禁擅自推送)*

**只有**获得这两个答案后，才能开始编写计划文件，并将决策结果记录在计划文件的顶部。

### 1. 必须创建计划文件

- 你**必须**在 `docs/plans/` (或类似目录) 下创建一个新的 Markdown 文件。
- **语言要求**：计划文件的所有描述性内容**必须**使用中文编写。
- 文件名必须包含日期和任务描述（如 `2024-05-20-auth-refactor.md`）。
- **必须**在计划文件开头引用所依据的 **设计文档 (Spec)** 路径。
- **严禁**只在对话中列出计划。

### 2. 必须遵循“五步循环”结构

每个任务项必须包含以下子步骤（隐式或显式）：
1.  **手动测试/复现**：确认现状（Red）。
2.  **编写测试**：创建自动化测试用例（Red）。
3.  **实施代码**：编写最小代码使测试通过（Green）。
4.  **验证通过**：运行测试并确认（Verification）。
5.  **提交代码**：git commit。

### 3. 步骤必须原子化

- **严禁**写“实现认证模块”这样的大步骤。
- **必须**拆解为：“创建 User 模型”、“实现登录 API”、“编写 JWT 校验中间件”等。
- 每个步骤的代码变更不应超过 50 行（除非是样板代码）。

### 4. 必须包含状态追踪

计划文件必须使用复选框 `[ ]` 来追踪进度。
- 每完成一步，**必须**更新文件，将 `[ ]` 改为 `[x]`。
- **严禁**在未完成验证的情况下打钩。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “我知道每一步要做什么，不需要写下来” | 你的工作记忆有限。被打断一次，你就会丢失上下文。 |
| “计划赶不上变化” | 计划就是用来应对变化的。通过更新计划来管理变化，而不是抛弃计划。 |
| “写测试太花时间了” | TDD 是最快的开发方式。没有测试，你将在调试上花费 10 倍的时间。 |
| “这个任务太小了” | 如果它小到不需要计划，那就直接做。但如果涉及到多个文件，它就不小。 |

## 危险信号 (Red Flags)

如果出现以下情况，**立即停止**并重写计划：

- 计划中只有一个步骤：“完成所有功能”。
- 步骤描述中没有提到“测试”或“验证”。
- 连续执行了 3 个步骤而没有更新计划文件。
- 直接开始写代码，而没有先创建计划文件。