---
name: writing-plans
description: 当持有已批准的设计规格 (Spec)，并准备进入多步骤实施阶段前使用，用于产出可追踪的执行蓝图。
---

# 编写实施计划 (Writing Implementation Plans)

## 概述

此技能是工程交付的“导航仪”。它通过将高层设计（Spec）拆解为一系列**原子化 (Atomic)**、**可验证 (Verifiable)** 的步骤，确保复杂任务的执行过程不产生逻辑偏移。计划文件不仅是待办清单，更是受版本控制的**审计追踪器**。

**核心原则：**
1.  **先计划，后执行 (Plan then Act)**：严禁在未产出并获批计划文件前编写任何生产代码。
2.  **验证即完成 (Verification is Done)**：每一个原子步骤必须定义明确的验证方法（主要是自动化测试）。
3.  **动态同步 (Live Documentation)**：计划必须实时反映真实进度。严禁执行与文档脱节的“隐形开发”。

## 何时使用

- **前置条件**：已通过 `brainstorming` 产出了设计文档 (Spec) 并获得了用户批准。
- 任务涉及跨越多个文件、模块，或预计执行轮次超过 3 次时。
- 需要通过 `subagent-driven-development` 进行任务委派前。
- **严禁使用于**：单行热修复、纯文本拼写纠正。

## 核心法则

### 1. 必须执行“零号决策” (Zero-Point Check)
在创建文件前，**必须**明确向用户确认以下两条决策，并记录在计划顶部：
- **工作区模式 (Workspace Mode)**：
    - 是在当前目录开发，还是创建独立的 `Git Worktree`？
- **交付模式 (Delivery Mode)**：
    - 是每一步后由智能体自动执行 `Local Auto-commit`，还是由用户手动提交？

### 2. 必须创建标准化计划文件
- **动作**：必须在 `docs/plans/[YYYY-MM-DD]-[task-name].md` 创建文件。
- **关联性**：必须在开头显式引用所依据的 **Spec 文档路径**。
- **语言**：描述内容必须使用专业、简洁的中文。

### 3. 必须执行“原子化”拆解
- **粒度要求**：每个步骤的代码改动不应超过 50 行（除样板代码外）。
- **结构要求**：每个步骤必须包含：
    1.  **任务描述**：做什么？
    2.  **验证手段**：运行哪个具体的测试命令？
    3.  **文件范围**：涉及哪些路径？

### 4. 强制执行“验证闭环”模板
每一个原子步骤必须隐含（或显式包含）以下循环：
- **(Red)**：编写测试并观察失败。
- **(Green)**：编写最小实现使测试通过。
- **(Verify)**：运行全量回归测试并记录日志到计划文件中。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “我已经想好怎么写了，没必要写下来” | 你的工作记忆在处理复杂逻辑时极其脆弱。计划是你的“外挂大脑”，能防止逻辑断层。 |
| “写计划太慢，不如直接开干” | 在实施中途发现架构走不通的重构成本，是写计划成本的 50 倍。 |
| “计划太详细了，改起来麻烦” | 详细的计划能让你在被打断后秒回状态。修改计划是管理变更的唯一科学方式。 |

## 危险信号 (Red Flags)

- **巨型步骤**：步骤描述中包含“实现 XXX 模块的所有逻辑”。 -> **必须拆解。**
- **验证缺失**：步骤后面没有跟具体的测试命令或验证脚本。
- **文档脱节**：直接在对话中列出步骤，而没有在磁盘上创建相应的 `.md` 文件。
- **无源之水**：没有引用任何已获批的 Spec 就开始写计划。
