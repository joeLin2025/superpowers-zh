---
name: systematic-debugging
description: 当遇到 Bug、测试失败或非预期行为时，在提出修复方案前使用，以确保基于证据的科学排障。
---

# 系统化调试 (Systematic Debugging)

## 概述

此技能是将调试从“玄学”转化为“科学”的严苛协议。它强制执行**归纳法排障 (Inductive Troubleshooting)**，要求在没有通过复现代码隔离变量并确定根因（Root Cause）之前，严禁进行任何生产代码的修改。

**核心原则：**
1.  **无复现，不审计 (No Repro, No Audit)**：无法复现的 Bug 不叫 Bug，叫“幽灵”。严禁尝试修复无法稳定重现的问题。
2.  **隔离变量 (Isolate Variables)**：每次只改变一个条件。若同时修改两个变量，你将永远无法确定是谁修复了问题。
3.  **证据链闭环 (Evidence Loop)**：所有的结论必须来自于日志、堆栈跟踪或变量快照，而非“我觉得”。

## 何时使用

- 测试套件中出现红色失败（Failures）时。
- 应用程序在运行时抛出异常（Exceptions）或崩溃时。
- 业务逻辑产生的结果与预期不符，即使没有报错时。
- **严禁使用于**：已知原因的语法错误修正、纯展示性的 UI 调整。

## 核心法则

### 1. 必须执行“零号环境审计” (Sanity Check)
在分析逻辑前，**必须**排除环境干扰：
- **动作**：清除缓存（如 `node_modules`, `__pycache__`）、重启编译器、验证依赖库版本。
- **目的**：确保你调试的是代码逻辑，而非受污染的运行环境。

### 2. 必须产出“最小复现脚本” (Minimal Repro)
在修改代码前，**必须**创建一个最小化的、可独立运行的复现案例：
- **要求**：该脚本/测试必须能在当前环境下稳定产生预期的错误（Red）。
- **动作**：将复现失败的**完整错误日志**及**堆栈跟踪**粘贴到对话中。

### 3. 必须遵循“假设-验证”诊断流 (Hypothesis-Testing)
- **提出假设**：基于日志，明确指出“我认为错误发生在 [文件:行号]，原因是 [具体逻辑异常]”。
- **策略运用**：
    - **二分注释法 (Binary Commenting)**：通过注释一半逻辑来快速定位问题区间。
    - **追踪打桩 (Trace Logging)**：在关键路径插入 `Log`，打印变量的实时状态与预期值的偏差。
- **铁律**：严禁在未确认根因的情况下，通过添加 `if (x != null)` 等方式进行补丁式修复（Patcher's approach）。

### 4. 必须执行“双向验证” (Dual-Way Verification)
修复代码后，**必须**：
1.  **正面验证**：运行“最小复现脚本”，确保其变为绿色（Green）。
2.  **反向回归**：运行项目全量测试，确保修复没有破坏原有功能。

### 5. 必须进行“工程反思” (Reflection)
修复完成后，**必须**简要回答：
- 为什么之前的测试没能捕捉到这个 Bug？
- 我是否需要为此添加一个永久性的回归测试用例？

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个 Bug 我以前见过，我知道怎么修” | 类似的症状可能由不同的根因引起。跳过诊断会导致你在错误的路径上浪费更多时间。 |
| “复现流程太复杂了，我直接改改看吧” | 猜测式编程是低效的。没有复现脚本，你永远无法 100% 确定你修好了它。 |
| “我已经在本地手动点过了，没问题” | 手动点击是不可重复的。只有自动化复现脚本才能在未来的重构中保护这段逻辑。 |

## 危险信号 (Red Flags)

- **“试错”式修改**：连续尝试了 2 个以上的不同修复方案，且都不起作用。 -> **立即停止，回到诊断阶段。**
- **掩盖症状**：通过增加 Try-Catch 或 Null 检查来让报错消失，但并没有解决产生异常的源头。
- **静态分析迷信**：只盯着代码看而拒绝运行代码打日志。运行时状态往往出乎意料。
- **超时修复**：试图通过增加 `sleep` 或延时来解决竞态条件问题。