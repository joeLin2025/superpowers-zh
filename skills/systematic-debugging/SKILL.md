---
name: systematic-debugging
description: 当遇到任何 Bug、测试失败或意外行为时，在提出修复建议之前使用。
---

# 系统化调试 (Systematic Debugging)

## 概述

此技能强制执行科学的调试流程，杜绝猜测式编程。

**核心原则：**
1.  **无复现，不修复**：如果你不能稳定地复现 Bug，你就无法验证修复。
2.  **隔离变量**：每次只改变一个变量，观察结果。
3.  **证据先行**：所有的假设都必须有日志、测试或报错信息作为支撑。

## 何时使用

- 遇到测试失败时。
- 遇到运行时错误或异常时。
- 遇到行为不符合预期（即使没有报错）时。
- **严禁**在看到错误信息后立即说“我知道了，让我试着改一下 X”。

## 核心法则

### 1. 必须分阶段执行

调试过程**必须**严格遵循以下顺序，严禁跳步：

0.  **环境验证 (Sanity Check)**：
    - 在深入代码之前，**必须**排除低级干扰：清除构建缓存、重启服务、检查依赖版本。
    - 确认不是环境污染导致的“幽灵 Bug”。

1.  **复现 (Reproduction)**：
    - 创建一个最小复现脚本或测试用例。
    - **必须**看到它失败（Red）。
    - **必须**将具体的错误信息、堆栈跟踪粘贴到对话中作为证据。

2.  **诊断 (Diagnosis)**：
    - 提出假设（“我认为是 A 导致了 B”）。
    - 策略选择：
        - **二分法 (Binary Search)**：如果代码量大，通过注释一半代码或 `git bisect` 快速缩小范围。
        - **日志追踪**：在关键路径打桩，追踪数据流。
    - 验证假设。
    - **必须**找到根本原因（Root Cause），而不仅仅是表面症状。

3.  **修复 (Fix)**：
    - 应用修复代码。
    - **必须**运行复现脚本，确认它通过（Green）。
    - **必须**运行相关测试，确保没有回归（Regression）。

4.  **反思 (Reflection)**：
    - 为什么之前的测试没有捕获这个问题？
    - 是否需要添加新的测试用例？

### 2. 严禁盲目尝试

- **严禁**说“可能是 X，让我试试”。
- **严禁**一次性修改多个地方希望“碰巧”修好。
- **严禁**在没有理解错误原因的情况下，通过添加 `if (x) return` 来掩盖错误。

### 3. 必须记录日志

- 在诊断过程中，**必须**使用打印语句（或日志工具）来追踪执行流和变量状态。
- **严禁**只看代码静态分析。运行时状态往往与你想象的不同。
- 修复完成后，**必须**清理临时日志。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这是个常见错误，我一眼就看出来了” | 即使是常见错误，上下文也可能不同。验证只需几秒钟。 |
| “复现太麻烦了，我直接改代码吧” | 没有复现，你就不知道你是否真的修好了它，还是只是把它藏起来了。 |
| “我没有时间写测试” | 你没有时间一遍又一遍地手动测试。自动化测试是一劳永逸的。 |
| “这只是个临时的修复” | 临时修复往往变成永久的技术债务。现在就做对。 |

## 危险信号 (Red Flags)

如果出现以下情况，**立即停止**并重置流程：

- 连续尝试了 3 次修复都失败了。 -> **停止。你的假设是错的。回到诊断阶段。**
- 修改了代码，但错误信息变了，你却不知道为什么。
- 你在没有任何日志输出的情况下盯着代码看了 5 分钟。
- 你试图通过增加超时时间或添加 `sleep` 来修复竞态条件。