---
name: systematic-debugging
description: 当遇到任何 Bug、测试失败或意外行为时，在提出修复方案之前使用
---

# 系统化调试 (Systematic Debugging)

## 概述

随机修复浪费时间并制造新的 Bug。快速补丁掩盖了底层问题。

**核心原则：** 始终在尝试修复之前找到根本原因。症状修复即是失败。

**违反此流程的字面意义就是违反调试的精神。**

## 铁律

```
NO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST
(没有根本原因调查，绝不修复)
```

如果你没有完成第一阶段，你就不能提出修复方案。

**调试过程中的假设分析、观察结果记录以及给用户的修复建议必须使用中文。**

## 何时使用

用于任何技术问题：
- 测试失败
- 生产中的 Bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**特别在以下情况使用：**
- 时间紧迫（紧急情况让人想猜测）
- “只需一个快速修复”看起来很明显
- 你已经尝试了多种修复
- 以前的修复不起作用
- 你不完全理解这个问题

**在以下情况不要跳过：**
- 问题看起来很简单（简单的 Bug 也有根本原因）
- 你很匆忙（匆忙保证返工）
- 经理想要现在就修复（系统化比乱试更快）

## 四个阶段

你必须在进行下一阶段之前完成每个阶段。

### 阶段 1: 根本原因调查

**在尝试任何修复之前：**

1. **仔细阅读错误消息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 记下行号、文件路径、错误代码

2. **一致地重现**
   - 你能可靠地触发它吗？
   - 确切步骤是什么？
   - 每次都会发生吗？
   - 如果不可重现 → 收集更多数据，不要猜测

3. **检查最近的更改**
   - 什么改变可能导致这种情况？
   - Git diff，最近的提交
   - 新的依赖项，配置更改
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件时 (CI → build → signing, API → service → database):**

   **在提出修复之前，添加诊断仪表：**
   ```
   对于每个组件边界：
     - 记录什么数据进入组件
     - 记录什么数据离开组件
     - 验证环境/配置传播
     - 检查每一层的状态

   运行一次以收集显示哪里损坏的证据
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

   **示例 (多层系统):**
   ```bash
   # Layer 1: Workflow
   echo "=== Secrets available in workflow: ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # Layer 2: Build script
   echo "=== Env vars in build script: ==="
   env | grep IDENTITY || echo "IDENTITY not in environment"

   # Layer 3: Signing script
   echo "=== Keychain state: ==="
   security list-keychains
   security find-identity -v

   # Layer 4: Actual signing
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **这揭示了：** 哪一层失败 (secrets → workflow ✓, workflow → build ✗)

5. **追踪数据流**

   **当错误位于调用栈深处时：**

   参见此目录中的 `root-cause-tracing.md` 了解完整的向后追踪技术。

   **快速版本：**
   - 坏值源自哪里？
   - 什么用坏值调用了这个？
   - 持续向上追踪直到找到源头
   - 在源头修复，而不是在症状处

### 阶段 2: 模式分析

**在修复前找到模式：**

1. **查找工作示例**
   - 在同一代码库中定位类似的正常工作代码
   - 有什么与损坏的东西类似且正常工作的？

2. **与参考进行比较**
   - 如果实施模式，完整阅读参考实施
   - 不要略读 - 阅读每一行
   - 在应用之前完全理解模式

3. **识别差异**
   - 工作与损坏之间有什么不同？
   - 列出每一个差异，无论多么小
   - 不要假设“那无关紧要”

4. **理解依赖关系**
   - 这还需要哪些其他组件？
   - 什么设置、配置、环境？
   - 它做了什么假设？

### 阶段 3: 假设与测试

**科学方法：**

1. **形成单一假设**
   - 清楚陈述：“我认为 X 是根本原因，因为 Y”
   - 写下来
   - 具体，不要模糊

2. **最小化测试**
   - 做尽可能小的改变来测试假设
   - 一次一个变量
   - 不要一次修复多件事

3. **继续前验证**
   - 有效吗？是 → 阶段 4
   - 无效？形成新假设
   - **不要**叠加更多修复

4. **当你不知道时**
   - 说“我不理解 X”
   - 不要假装知道
   - 寻求帮助
   - 研究更多

### 阶段 4: 实施

**修复根本原因，而不是症状：**

1. **创建失败的测试用例**
   - 最简单的可能重现
   - 如果可能，自动化测试
   - 如果没有框架，一次性测试脚本
   - 修复前必须有
   - 使用 `superpowers-zh:test-driven-development` 技能编写正确的失败测试

2. **实施单一修复**
   - 解决已识别的根本原因
   - 一次一个更改
   - 没有“顺便改进”
   - 没有捆绑重构

3. **验证修复**
   - 测试现在通过了吗？
   - 没有其他测试损坏？
   - 问题实际上解决了吗？

4. **如果修复不起作用**
   - 停止
   - 计数：你尝试了多少次修复？
   - 如果 < 3: 返回阶段 1，用新信息重新分析
   - **如果 ≥ 3: 停止并质疑架构 (见下文步骤 5)**
   - 在没有架构讨论的情况下不要尝试修复 #4

5. **如果 3+ 修复失败：质疑架构**

   **指示架构问题的模式：**
   - 每个修复都在不同地方揭示了新的共享状态/耦合/问题
   - 修复需要“大规模重构”来实施
   - 每个修复都在其他地方产生新症状

   **停止并质疑基本面：**
   - 这种模式从根本上是健全的吗？
   - 我们是不是“仅仅因为惯性而坚持它”？
   - 我们应该重构架构还是继续修复症状？

   **在尝试更多修复之前与你的人类伙伴讨论**

   这**不是**一个失败的假设 - 这是一个错误的架构。

## 危险信号 - 停止并遵循流程

如果你发现自己在想：
- “现在快速修复，稍后调查”
- “只需尝试更改 X 看看是否有效”
- “添加多个更改，运行测试”
- “跳过测试，我会手动验证”
- “可能是 X，让我修复它”
- “我不完全理解但这可能有效”
- “模式说 X 但我会以不同方式调整它”
- “这里有主要问题：[未调查就列出修复]”
- 在追踪数据流之前提出解决方案
- **“再一次修复尝试”（当已经尝试 2+ 次时）**
- **每个修复都在不同地方揭示新问题**

**所有这些意味着：停止。返回阶段 1。**

**如果 3+ 修复失败：** 质疑架构（见阶段 4.5）

## 你的人类伙伴的信号表明你做错了

**注意这些重定向：**
- “那个没有发生吗？” - 你假设而未验证
- “它会向我们展示...吗？” - 你应该添加证据收集
- “停止猜测” - 你在不理解的情况下提出修复
- “深度思考这个 (Ultrathink this)” - 质疑基本面，不仅仅是症状
- “我们卡住了？”（沮丧） - 你的方法不起作用

**当你看到这些：** 停止。返回阶段 1。

## 常见合理化

| 借口 | 现实 |
|--------|---------|
| “问题很简单，不需要流程” | 简单问题也有根本原因。流程对于简单 Bug 很快。 |
| “紧急情况，没时间走流程” | 系统化调试比猜测-检查的折腾**更快**。 |
| “先试试这个，然后调查” | 第一个修复设定了模式。从一开始就做对。 |
| “我会在确认修复有效后写测试” | 未经测试的修复站不住脚。先测试证明它。 |
| “一次多个修复节省时间” | 无法隔离什么有效。导致新 Bug。 |
| “参考太长，我会调整模式” | 部分理解保证 Bug。完整阅读它。 |
| “我看到问题了，让我修复它” | 看到症状 ≠ 理解根本原因。 |
| “再一次修复尝试”（在 2+ 失败后） | 3+ 失败 = 架构问题。质疑模式，不要再次修复。 |

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|-------|---------------|------------------|
| **1. 根本原因** | 阅读错误，重现，检查更改，收集证据 | 理解**什么 (WHAT)** 和 **为什么 (WHY)** |
| **2. 模式** | 查找工作示例，比较 | 识别差异 |
| **3. 假设** | 形成理论，最小化测试 | 确认或新假设 |
| **4. 实施** | 创建测试，修复，验证 | Bug 解决，测试通过 |

## 当流程揭示“无根本原因”时

如果系统化调查揭示问题确实是环境性的、依赖于时间的或外部的：

1. 你已经完成了流程
2. 记录你调查的内容
3. 实施适当的处理（重试，超时，错误消息）
4. 添加监控/日志以供未来调查

**但是：** 95% 的“无根本原因”案例是不完整的调查。

## 支持技术

这些技术是系统化调试的一部分，并在此目录中可用：

- **`root-cause-tracing.md`** - 通过调用栈向后追踪 Bug 以找到原始触发点
- **`defense-in-depth.md`** - 在找到根本原因后在多层添加验证
- **`condition-based-waiting.md`** - 用条件轮询替换任意超时

**相关技能：**
- **superpowers-zh:test-driven-development** - 用于创建失败的测试用例（阶段 4，步骤 1）
- **superpowers-zh:verification-before-completion** - 在宣布成功前验证修复有效

## 现实世界影响

来自调试会话：
- 系统化方法：15-30 分钟修复
- 随机修复方法：2-3 小时的折腾
- 首次修复率：95% vs 40%
- 引入的新 Bug：接近零 vs 常见
