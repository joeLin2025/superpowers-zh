---
name: dispatching-parallel-agents
description: 当面临 2 个及以上可独立进行、无共享状态且无顺序依赖的任务时，用于调度多个并行智能体以提升执行效率。
---

# 调度并行智能体 (Dispatching Parallel Agents)

## 概述

此技能是应对大规模系统性故障或多点并发需求的“吞吐量倍增器”。其核心在于通过**原子任务解构 (Atomic Task Deconstruction)**，在物理隔离的前提下，利用多个独立智能体并行执行任务，从而大幅缩短交付周期。

**核心原则：**
1.  **物理级互斥 (Physical Mutex)**：任务间严禁操作同一文件或紧密耦合的共享模块。
2.  **指令完备性 (Instruction Sufficiency)**：每个智能体必须持有独立的、足以完成任务的上下文及验证依据。
3.  **最终集成验证 (Final Integration Guardrail)**：所有的并发产出必须在合并后经过全量回归测试。

## 何时使用

- **多点故障并发**：3 个以上独立的测试文件报错，且错误原因各异。
- **解耦模块同步开发**：需要在多个互不依赖的子系统（如：Auth 模块和 Logging 模块）中同步实施变更。
- **大规模文档/格式化**：对多个独立目录执行无逻辑依赖的清理工作。
- **严禁使用于**：修复具有因果关系的连锁故障、修改同一个核心公共函数、或由于不确定根因导致的盲目并行。

## 核心法则

### 1. 必须执行“冲突预检” (Conflict Pre-flight)
在调度任何智能体前，**必须**显式检查任务的物理边界：
- **动作**：列出每个任务计划修改的文件列表。
- **铁律**：若两个任务的文件列表存在交集（Intersection），**严禁并行**，必须改为串行执行。

### 2. 必须实施“闭环委派” (Closed-loop Delegation)
分派给每个智能体的 Prompt **必须**包含：
- **目标域**：具体的文件路径和函数。
- **验证域**：必须运行并成功的测试用例名称 (Test Case Name)。
- **负面约束**：严禁修改非目标文件，严禁执行非必要的重构。
- **汇报协议**：必须使用中文总结改动点及验证证据。

### 3. 必须执行“全量回归” (Full Regression)
即使各智能体报告任务成功，主智能体在合并代码后**必须**：
- 执行 `git diff` 审计全局改动。
- 运行项目的**全量测试套件**（而不仅是各任务相关的测试），以探测隐性耦合导致的回归错误。

### 4. 严禁模糊委派 (No Ambiguous Tasks)
- **禁止**发送“请尝试修复这些报错”等模糊指令。
- **必须**附带具体的堆栈跟踪 (Stack Trace) 片段或错误日志行号。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “我可以直接一个一个修，也不慢” | 单兵作战的吞吐量上限决定了项目上限。学会调度是向架构师进阶的必经之路。 |
| “反正改的地方不一样，肯定不会冲突” | 物理不冲突不代表逻辑不冲突。缺乏预检的并行是“集成地狱”的入场券。 |
| “分派任务写 Prompt 太麻烦了” | 高质量的指令能减少 90% 的返工。模糊的指令是在制造更多 Bug。 |

## 危险信号 (Red Flags)

- **文件所有权冲突**：两个 Agent 同时获得了对同一个文件的修改指令。
- **验证依据缺失**：给 Agent 分派了任务但没有提供明确的测试命令。
- **忽略集成测试**：在未运行全量回归的情况下就声称“并行任务全部完成”。
- **单点阻塞**：一个 Agent 失败导致主智能体停滞，说明任务分解时存在未识别的依赖关系。
