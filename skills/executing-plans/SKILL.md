---
name: executing-plans
description: 当需要严格按照书面计划分批执行任务，并确保每一步都经过验证与审查时使用。
---

# 执行计划 (Executing Plans)

## 概述

此技能是将静态实施计划转化为动态、受控变更的“工程准则”。它通过**分批次执行 (Batch execution)** 与 **原子化状态同步 (Atomic State Synchronization)**，确保复杂工程任务在每一步都具备可追溯性、透明性和可验证性。

**核心原则：**
1.  **计划至上 (Plan Supremacy)**：计划是执行的唯一合法蓝图。严禁在计划外进行任何“顺便”或“隐形”的改动。
2.  **证据物化 (Evidence Materialization)**：所有的验证结果（测试日志、输出片段）必须持久化记录在计划文件中，作为审计链。
3.  **熔断检查点 (Failsafe Checkpoints)**：在关键批次结束时强制停顿，通过人工干预防止由于逻辑惯性导致的错误累积。

## 何时使用

- 持有由 `writing-plans` 生成的结构化计划文件时。
- 执行涉及多文件、多步骤的高风险架构变更时。
- 协作开发中，需要向外部展示精确进度和验证证据时。
- **严禁使用于**：无固定路径的探索性调研、纯文档编写、或极其微小的单行热修复。

## 核心法则

### 1. 计划审计与对齐 (Audit & Alignment)
在执行第一步前，**必须**完整加载计划文件：
- **审查**：若发现计划中的文件路径错误、测试命令失效或逻辑环，**严禁开始执行**，必须先修正计划。
- **对齐**：明确宣称：“我正在根据 [文件名] 执行第 N 批次任务。”

### 2. 原子化状态同步 (State Sync)
执行过程中，**必须**保持计划文件与实际操作的同步：
- **执行前**：将任务标记为 `[ ] (进行中)`。
- **执行后**：将任务标记为 `[x]`。
- **强制要求**：将关键的验证日志输出（如测试成功的最后 5 行）直接追加在计划文件的任务条目下方。**禁止**仅在聊天中口头承诺。

### 3. 分批次执行与停顿 (Batch & Halt)
- **硬性上限**：每个执行批次不得超过 **3 个原子任务**。
- **强制停顿**：批次结束后，**必须**停止并请求用户审查计划文件中的更新。严禁在未获得明确“继续”信号前进入下一批次。
- **交付模式匹配**：严格遵守计划定义的 `Delivery Mode`。若为 `Local Auto-commit`，则每步完成后必须执行 `git commit`。

### 4. 严禁计划外漂移 (No Execution Drift)
- **漂移检测**：若在执行中发现必须修改计划外文件，或原有步骤无法走通，**立即停止**。
- **修正路径**：**必须**先更新计划文件并获得批准，再继续执行。严禁“边做边改计划”。

### 5. 阻塞熔断 (Execution Failsafe)
- 遇到任何非预期的测试失败、环境报错或指令模糊，**必须立即触发熔断**。
- **严禁猜测执行**。在这种情况下，寻求澄清是保持工程纪律的唯一方式。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个改动很小，顺便做了没关系” | 所有的“顺便”都是由于缺乏纪律导致的风险。坚持“先计划，后执行”是区分专家与学徒的分水岭。 |
| “我已经贴过日志了，不用写在文件里” | 对话记录会被滚动淹没，文件才是持久的证据。没有记录在文件中的验证一律视为无效。 |
| “我一次性做完再汇报更高效” | 步子迈得太大容易扯到逻辑。分批次汇报是成本最低的纠错机制。 |

## 危险信号 (Red Flags)

- **隐形修改**：修改了计划中未列出的文件或函数。
- **证据真空**：计划文件中只有 `[x]` 但没有任何附加的验证日志。
- **逻辑跳步**：在步骤 N 失败的情况下强行尝试步骤 N+1。
- **静默执行**：连续执行超过 3 个任务而没有任何反馈请求或计划更新。
