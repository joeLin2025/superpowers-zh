---
name: test-driven-development
description: 在实施任何逻辑变更或修复 Bug 之前使用，强制执行先写测试、后写实现的研发模式。
---

# 测试驱动开发 (Test Driven Development)

## 概述

此技能是确保代码库“零回归、高内聚、易重构”的终极防线。它通过强制执行**红-绿-重构 (Red-Green-Refactor)** 的三位一体循环，将开发过程转化为一系列可验证的小步快跑，确保每一行生产代码都具备存在的合理性。

**核心原则：**
1.  **测试先行 (Test First)**：没有失败的测试，就没有任何理由写任何一行生产代码。
2.  **最小化实现 (Minimal Implementation)**：只编写刚好能让当前测试通过的代码。**硬编码 (Hardcoding)** 返回值在“绿”阶段不仅是允许的，而且是被鼓励的。
3.  **零容忍补测 (No Late Testing)**：严禁在写完实现后“补写”测试。补写的测试通常带有偏见且难以发现架构缺陷。

## 何时使用

- 增加新功能或新接口时。
- 修复已知 Bug（先写重现测试）时。
- 准备进行代码重构以提升可维护性时。
- **严禁使用于**：纯 UI 样式调整（如颜色、边距）、纯文档更新、或无法通过自动化工具模拟的硬件级交互。

## 核心法则

### 1. 必须遵循 R-G-R 铁律
你**必须**严格按顺序执行以下动作，严禁跳步：

1.  **红 (Red)**：
    -   编写一个测试用例，断言一个尚未实现的行为。
    -   运行测试并**看到它失败**（必须核实失败原因与预期一致）。
    -   提交代码：`test: expect failure for [feature-name]`。

2.  **绿 (Green)**：
    -   编写**最少量**的代码让测试通过。
    -   **原理**：此时不追求代码优雅，只追求快速变绿。
    -   提交代码：`feat: pass test for [feature-name]`。

3.  **重构 (Refactor)**：
    -   在测试保护下，消除冗余、优化命名、提升抽象。
    -   **铁律**：重构阶段**严禁**增加任何新功能。
    -   再次运行测试，确保仍然为绿。
    -   提交代码：`refactor: optimize [feature-name]`。

### 2. 必须实施“原子化”测试命名
- **要求**：测试名称必须是一个清晰的行为陈述句。
- **格式**：`should_[expected_behavior]_when_[condition]`（如 `should_raise_error_when_api_key_is_missing`）。
- **严禁**：使用 `test1`, `check_logic` 等无法传达业务语义的名称。

### 3. 必须彻底删除“无主代码”
- 若发现任何一行生产代码没有对应的自动化测试覆盖，**必须立即删除**。
- **原理**：未经测试的代码是系统的债务和不确定性来源。删除它是降低系统熵增的最佳手段。

### 4. 必须保持“隔离性” (Isolation)
- **要求**：每个测试必须是独立的。一个测试的成功或失败不应依赖于另一个测试的执行顺序。
- **环境清理**：在 `setUp` 或 `tearDown` 中必须清理数据库、缓存或模拟对象，防止状态污染。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个逻辑太简单了，写测试是浪费时间” | 越简单的逻辑越容易在未来的重构中被意外破坏。测试是给未来的自己买的保险。 |
| “我不知道怎么测这个数据库/网络调用” | 这说明你的代码耦合度太高。通过 Mock 或依赖注入将其解耦。TDD 会逼你写出更好的架构。 |
| “我先写实现，保证 5 分钟后补上测试” | 人的自律是不可靠的。一旦实现跑通，你就会失去写测试的动力。坚持 R-G-R 是工程纪律的底线。 |

## 危险信号 (Red Flags)

- **“先写代码，后写测试”**：你正在进行的不是 TDD，而是“测试辅助开发”。
- **测试一直为绿**：你可能写了一个无效断言（如 `assert True`），或者测试了已经存在的行为。
- **注释掉失败的测试**：这被视为“掩耳盗铃”，是极度严重的质量违规。
- **重构阶段引入了新逻辑**：这会破坏 R-G-R 循环的单一职责，导致回归风险无法控制。
