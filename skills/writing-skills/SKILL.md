---
name: writing-skills
description: 创建新技能、编辑现有技能或在部署前验证技能时使用。
---

# 编写技能 (Writing Skills)

## 概述

**编写技能就是应用于流程文档的测试驱动开发 (TDD)。**

你编写测试用例（使用子智能体的压力场景），观察它们失败（基线行为），编写技能（文档），观察测试通过（智能体遵守），并重构（堵塞漏洞）。

**核心原则：** 如果你没有亲眼看到智能体在没有技能的情况下失败，你就不知道该技能是否教导了正确的东西。

**必备背景：** 在使用此技能之前，你**必须**了解 `test-driven-development`。该技能定义了基本的 RED-GREEN-REFACTOR 循环。此技能将 TDD 改编为文档编写。

## 什么是技能？

**技能**是经过验证的技术、模式或工具的参考指南。技能帮助未来的 Gemini 实例找到并应用有效的方法。

**技能是：** 可重用的技术、模式、工具、参考指南。
**技能不是：** 关于你曾经如何解决问题的叙述。

## 技能的 TDD 映射

| TDD 概念 | 技能创建 |
|-------------|----------------|
| **测试用例** | 使用子智能体的压力场景 |
| **生产代码** | 技能文档 (SKILL.md) |
| **测试失败 (红)** | 智能体在没有技能的情况下违反规则（基线） |
| **测试通过 (绿)** | 智能体在有技能的情况下遵守规则 |
| **重构** | 在保持合规的同时堵塞漏洞 |
| **先写测试** | 在编写技能之前运行基线场景 |
| **观察它失败** | 记录智能体使用的确切借口 |
| **最小化代码** | 编写解决这些特定违规行为的技能 |
| **观察它通过** | 验证智能体现在是否遵守 |
| **重构循环** | 找到新的借口 → 堵塞 → 重新验证 |

整个技能创建过程遵循 RED-GREEN-REFACTOR。

## 何时创建技能

**创建时机：**
- 技术对你来说并不直观。
- 你会在跨项目中再次引用它。
- 模式广泛适用（非特定于项目）。
- 其他人会受益。

**不要为以下情况创建：**
- 一次性解决方案。
- 在其他地方已有详细记录的标准实践。
- 特定于项目的约定（放入 GEMINI.md）。
- 机械约束（如果可以通过 regex/验证强制执行，请自动化它——将文档留给判断调用）。

## 目录结构

```
skills/
  skill-name/
    SKILL.md              # 主要参考（必需）
    supporting-file.*     # 仅在需要时
```

**扁平命名空间** - 所有技能都在一个可搜索的命名空间中。

## SKILL.md 结构

**Frontmatter (YAML):**
- 仅支持两个字段：`name` 和 `description`。
- `name`: 仅使用字母、数字和连字符。
- `description`: 第三人称，仅描述何时使用（**而不是**它做什么）。
  - 以“当...时使用”开头，关注触发条件。
  - **切勿总结技能的流程或工作流**。

```markdown
---
name: Skill-Name-With-Hyphens
description: 当 [具体触发条件和症状] 时使用
---

# 技能名称

## 概述
这是什么？核心原则 1-2 句话。

## 何时使用
[如果决策不明显，使用小型内联流程图]

带有症状和用例的列表
何时不使用

## 核心模式 (针对技术/模式)
代码对比 (Before/After)

## 快速参考
用于扫描常见操作的表格或要点

## 常见错误
出了什么问题 + 修复

## 真实世界影响 (可选)
具体结果
```

## Gemini 搜索优化 (GSO)

**发现的关键：** 未来的 Gemini 需要找到你的技能。

### 1. 丰富的描述字段

**目的：** Gemini 阅读描述以决定为给定任务加载哪些技能。
**格式：** 以“当...时使用”开头。
**关键：描述 = 何时使用，而不是技能做什么**

不要在描述中总结技能的流程。

### 2. 关键词覆盖

使用 Gemini 会搜索的词：
- 错误消息。
- 症状（“不稳定”、“挂起”）。
- 同义词。
- 工具名称。

### 3. 描述性命名

**使用主动语态，动词优先：**
- ✅ `creating-skills` 不是 `skill-creation`

### 4. 交叉引用其他技能

使用技能名称，带有明确的要求标记：
- ✅ Good: `**必需子技能：** 使用 test-driven-development`

**不要使用 @ 链接：** `@` 语法会立即强制加载文件，消耗上下文。

## 铁律 (同 TDD)

```
没有先写失败测试，就没有技能
```

这适用于新技能**和**对现有技能的编辑。

**没有例外：**
- 不适用于“简单的添加”。
- 不适用于“文档更新”。
- 删除就是删除。

## 针对借口对技能进行防弹

强制执行纪律的技能（如 TDD）需要抵制合理化。

### 显式关闭每个漏洞

不要只陈述规则——禁止具体的变通方法。

### 解决“精神与字面”的争论

尽早添加基本原则：
```markdown
**违反规则的字面意思就是违反规则的精神。**
```

### 建立借口表

从基线测试中捕获借口：

```markdown
| 借口 | 现实 |
|--------|---------|
| “太简单了不需要测试” | 简单的代码也会出错。写测试只需 30 秒。 |
```

### 创建危险信号列表

让智能体容易自查：

```markdown
## 危险信号 - 停止并重新开始

- 先写代码
- “我已经手动测试过了”
- “这是不同的，因为...”

**所有这些都意味着：删掉代码。使用 TDD 重新开始。**
```

## 技能创建清单 (TDD 适配)

**红色阶段 - 编写失败测试：**
- [ ] 创建压力场景。
- [ ] 在没有技能的情况下运行场景——记录基线行为。
- [ ] 识别借口/失败中的模式。

**绿色阶段 - 编写最小技能：**
- [ ] Frontmatter 只有 name 和 description。
- [ ] 描述以“当...时使用”开头。
- [ ] 包含搜索关键词。
- [ ] 清晰的概述和核心原则。
- [ ] 解决在红色阶段识别的具体基线失败。
- [ ] 一个优秀的示例。
- [ ] 在有技能的情况下运行场景——验证智能体现在遵守。

**重构阶段 - 堵塞漏洞：**
- [ ] 识别来自测试的新借口。
- [ ] 添加显式反击。
- [ ] 建立借口表。
- [ ] 创建危险信号列表。

## 底线

**编写技能就是流程文档的 TDD。**

同样的铁律：没有先写失败测试就没有技能。
同样的循环：红（基线）→ 绿（编写技能）→ 重构（堵塞漏洞）。
同样的收益：更好的质量，更少的意外，防弹的结果。
