---
name: writing-skills
description: 当需要创建新技能、重构现有技能或为特定工程挑战建立新的行为准则时使用。
---

# 编写技能 (Writing Skills)

## 概述

此技能是将技能文档视为**可执行代码**的“编译器”。它确立了技能构建的 TDD 范式，强制要求通过**基线压力测试 (Baseline Stress Test)** 来验证规则的有效性。技能文档不是建议，而是智能体在特定场景下的最高法律。

**核心原则：**
1.  **无基线，不构建 (No Baseline, No Build)**：严禁在未观察到“没有该技能时的行为失败”前编写规则。
2.  **防御性架构 (Defensive Architecture)**：技能必须预判并封堵智能体的每一个潜在借口，建立认知的“防火墙”。
3.  **约束性语态 (Imperative Tone)**：所有的规则必须使用强约束性动词。拒绝模棱两可，拥抱绝对控制。

## 何时使用

- 发现智能体在特定任务中反复出现逻辑偏差或“偷懒”时。
- 需要将复杂的工程最佳实践（如：特定框架的开发规范）固化为自动执行流程时。
- 重构现有技能以提升其信噪比 (SNR) 或抗幻觉能力时。
- **严禁使用于**：记录项目特定的业务逻辑、单次脚本说明、或非通用性的配置项。

## 核心法则

### 1. 必须执行“技能级”TDD 循环
编写技能**必须**经过以下三个阶段，严禁盲写：
1.  **红 (Red - 发现偏差)**：
    -   构造一个会诱发智能体错误行为的 User Prompt（如：不写测试就给代码）。
    -   **必须**观察并记录智能体在无技能状态下的失败表现及使用的借口。
2.  **绿 (Green - 建立约束)**：
    -   编写针对该偏差的 `SKILL.md`。
    -   **必须**观察到智能体在激活技能后，因受到规则约束而修正了行为。
3.  **重构 (Refactor - 极致打磨)**：
    -   使用 `skill-localization-and-polishing` 进行表达压缩，封堵语义漏洞。

### 2. 必须强制执行“六段式”标准结构 (Output Standard)
所有技能文档**必须**包含以下一级标题，顺序严禁颠倒（Schema Validation）：

| 章节 | 标题 | 内容约束 |
| :--- | :--- | :--- |
| **0** | `Frontmatter` | `name` (kebab-case) + `description` (必须以“当...时使用”开头)。 |
| **1** | `概述` | 定义技能的“灵魂”与核心原则。 |
| **2** | `何时使用` | 精确的触发条件与**禁忌场景**。 |
| **3** | `核心法则` | 以“必须/严禁”开头的绝对命令。 |
| **4** | `借口粉碎机` | 预判偷懒思维并进行降维打击（表格形式）。 |
| **5** | `危险信号` | 定义任务的“熔断点”（列表形式）。 |

### 3. 必须实施“信噪比”极端审计
- **禁令**：严禁在正文中使用“请”、“建议”、“如果你愿意”、“通常来说”等废话。
- **禁令**：严禁描述“什么是技能”，只能描述“必须怎么做”。
- **约束**：每一个字都必须是为了**增加约束力**或**消除歧义**而存在的。

### 4. 必须通过“傻瓜/律师”双重测试
- **傻瓜测试**：确保指令在没有常识支撑时也不会被机械地执行错。
- **律师测试**：确保指令没有语义漏洞，防止智能体通过钻字眼来逃避高难度工作。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个规则很简单，我直接写出来就行” | 缺乏基线测试的规则往往是无效的。没有经过“红”阶段的验证，你无法证明规则解决了实际问题。 |
| “我以后再补齐‘借口粉碎机’” | 借口粉碎机是技能的“防御系统”。没有它的技能在复杂诱惑下会瞬间坍塌。 |
| “写得太生硬会让用户觉得不友好” | 技能是给智能体看的法律，不是给用户看的小说。友好的代价通常是执行力的丧失。 |

## 危险信号 (Red Flags)

- **建议性语态**：正文中出现了弱约束动词。
- **结构残缺**：缺少核心章节（特别是危险信号和借口表）。
- **描述功能而非场景**：在 `description` 中写“这个技能可以干什么”而不是“当...时使用”。
- **无源编写**：在没有真实行为偏差案例的情况下，凭空构思技能规则。
