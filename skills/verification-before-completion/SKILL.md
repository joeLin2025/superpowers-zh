---
name: verification-before-completion
description: 在声称工作已完成、已修复或已通过测试之前，在提交代码或创建 PR 之前使用。要求在做出任何成功声明之前运行验证命令并确认输出。始终坚持“先有证据，后有断言”。
---

# 完工前验证 (Verification Before Completion)

## 概述

此技能强制执行“证据优先”的完工标准。它禁止任何形式的口头保证，要求必须提供可复现的、具体的验证输出。

**核心原则：**
1.  **证据即真理**：没有日志输出的断言是无效的。
2.  **拒绝盲信**：即使是微小的改动，也可能破坏系统。必须验证。
3.  **穿透阅读**：必须阅读日志的详细内容，而不仅仅是看最后一行。

## 何时使用

- 准备说“我已经修复了 Bug”时。
- 准备提交代码 (git commit) 时。
- 准备创建 PR 时。
- 任何时候你想声称“这应该能工作”时。

## 核心法则

### 1. 五步验证法

在声明完成前，**必须**执行以下步骤：
1.  **识别 (Identify)**：明确你要验证什么？（Bug 修复了？新功能可用了？）
2.  **运行 (Run)**：执行具体的验证命令（测试、构建、脚本）。
3.  **扫盲 (Side-effect Scan)**：**必须**运行项目全量检查工具（如 `npm run lint`, `tsc`, `ruff check` 等），确保没有引入样式或类型错误。
4.  **阅读 (Read)**：逐行阅读输出日志。不要只看 `Exit Code`。
5.  **核对 (Delivery Check)**：根据 `writing-plans` 的决策，确认本地代码是否已全部提交 (Local Commit)。若在 Worktree 中，确认是否已准备好清理或切换。

### 2. 验证标准表

| 场景 | 合格证据 | 质量底线 |
|------|----------|------------|
| Bug 修复 | 复现脚本从失败变为成功的日志 | 必须通过 Lint + 无新回归测试失败 |
| 新功能 | 功能测试通过的日志 + 截图/演示 | 必须通过全量类型检查 (Type Check) |
| 重构 | 全量回归测试通过的日志 | 严禁降低原有的测试覆盖率 |
| 构建修复 | 成功构建的输出日志 | 必须包含清理旧缓存后的完整构建日志 |

### 3. 最终声明模板

在声称“任务完成”时，**必须**包含以下要素：
- **验证命令**：使用的具体命令。
- **证据链接**：指向计划文件中记录的 Log 所在行或片段。
- **交付状态**：确认已完成本地提交 (Local Commit) 并符合 Worktree 规范。

## 借口粉碎机 (Excuse Smasher)

| 借口 | 事实反击 |
|------|----------|
| “这个改动太小了，不用测” | 历史上 80% 的生产事故都是由“小改动”引起的。 |
| “运行测试太慢了” | 你的信誉比等待时间更重要。使用并行测试或只运行相关测试来加速。 |
| “我现在的环境跑不了测试” | 那你就不能提交代码。修复环境是第一优先级。 |
| “我看过代码了，逻辑是对的” | 编译器和运行时不关心你的逻辑是否“看起来”对。它们只关心事实。 |

## 危险信号 (Red Flags)

如果出现以下情况，**立即停止**并拒绝承认完工：

- 你的“证据”是“相信我”。
- 验证命令报错了，但你觉得“这是无关的错误”。
- 你运行了测试，但没有等待它跑完。
- 你只修复了报错信息，而没有修复根本原因。